I")<p>In a coding interview you have to demonstrate to your interviewer that you possess several key skills:</p>

<ul>
  <li>The ability to rigorously formulate real-world problems.</li>
  <li>The skills to solve problems and design algorithms.</li>
  <li>The tools to go from an algorithm to a working program.</li>
  <li>The analytical techniques required to determhe the computational complexity of your solution.</li>
</ul>

<p>There are a number of approaches to designing algorithms: exhaustive search, divide-and-conquer, greedy, randomized, parallelization, back-tracking, heuristic, reduction, approximation, etc.</p>

<p>You already need to know the basic data structures and algorithms to read this book. The authors recommend the book Algorithms by Dasgupta, Papadirnitriou, and Vazirani because it is succinct and beautifully written.</p>

<p>The book Algorithms for Interviews by Aziz and Prakash covers some common problem solving techniques. Letâ€™s briefly look at these problem solving techniques.</p>

<h2 id="divide-and-conquer">Divide and Conquer</h2>

<p>Can you divide the problem into two or more smaller independent sUbproblems and solve the original problem using solutions to the subproblems?</p>

<h2 id="recursion-and-dynamic-programmmg">Recursion and Dynamic Programmmg</h2>

<p>If you have access to solutions for smaller in- stances of a given problem, can you easily con- struct a solution to the problem?</p>

<h2 id="case-analysis">Case Analysis</h2>

<p>Can you split the input/execution into a number of cases and solve each case in isolation?</p>

<h2 id="generalization">Generalization</h2>

<p>Is there a problem that subsumes your probem and is easier to solve?</p>

<h2 id="data-structures">Data Structures</h2>

<p>Is there a data structure that directly maps to the given problem?</p>

<h2 id="iterative-refinement">Iterative Refinement</h2>

<p>Most problems can be solved using a brute-force approach. Can you formalize such a solution and improve it?</p>

<h2 id="small-examples">Small Examples</h2>

<p>Can you find a solution to small concrete instances of the problem and then build a solution that can be generalized to arbitrary instances?</p>

<h2 id="reduction">Reduction</h2>

<p>Can you use a problem with a known solution as a subroutine?</p>

<h2 id="graph-modeling">Graph Modeling</h2>

<p>Can you describe your problem using a graph and solve it using an existing algorithm?</p>

<h2 id="write-an-equation">Write an Equation</h2>

<p>Can you express relationships in your problem in the form of equations (or inequalities)?</p>

<h2 id="auxiliary-elements">Auxiliary Elements</h2>

<p>Can you add some new element to your problem to get closer to a solution?</p>

<h2 id="variation">Variation</h2>

<p>Can you solve a slightly different problem and map its solution to your problem?</p>

<h2 id="parallelism">Parallelism</h2>

<p>Can you decompose your problem into sub-problems that can be solved independently on different machines?</p>

<h2 id="caching">Caching</h2>

<p>Can you store some of your computation and look it up later to save work?</p>

<h2 id="symmetry">Symmetry</h2>

<p>Is there symmetry in the input space or solution space that can be exploited?</p>

<h2 id="conclusion">Conclusion</h2>

<p>Expert programmers do not rely on a set of rules. But the journey to becoming an expert programmer cannot bypass the phase where you need a set of rules to learn problem solving in the context of solving coding problems.</p>

<p>The book works through several coding problems to illustrate how to apply these problem solving techniques to a coding problem. You still need to learn which technique to apply to which problem. I highly recommend the Algorithms for Interviews book to build your problem solving toolbox for coding interviews. It provides the training wheels you need to become a problem solver.</p>
:ET