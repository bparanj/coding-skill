<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Big O Analysis of Algorithms - Coding Skill</title>

  <link rel="stylesheet" href="/assets/css/styles.css">
	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Big O Analysis of Algorithms | Coding Skill</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Big O Analysis of Algorithms" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="You need to know how to make time space trade offs when you’re solving a coding problem. Learn about the Big O analysis of algorithms. What is O(1) time? What is O(n)? Start analyzing the basic operations on the data structure you’re learning in terms of time and space complexity." />
<meta property="og:description" content="You need to know how to make time space trade offs when you’re solving a coding problem. Learn about the Big O analysis of algorithms. What is O(1) time? What is O(n)? Start analyzing the basic operations on the data structure you’re learning in terms of time and space complexity." />
<meta property="og:site_name" content="Coding Skill" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-15T00:00:00-06:00" />
<script type="application/ld+json">
{"description":"You need to know how to make time space trade offs when you’re solving a coding problem. Learn about the Big O analysis of algorithms. What is O(1) time? What is O(n)? Start analyzing the basic operations on the data structure you’re learning in terms of time and space complexity.","headline":"Big O Analysis of Algorithms","dateModified":"2019-08-15T00:00:00-06:00","datePublished":"2019-08-15T00:00:00-06:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/08/15/big-o-analysis.html"},"url":"/2019/08/15/big-o-analysis.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  
  <style>
  .note {
      background-color: #f7f7f7;
      line-height: 26px;
      margin: 30px 0;
      padding: 26px 30px 12px 30px;
      border-left-style: solid;
      border-left-width: 4px;
      border-color: #008000;
  	  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  		border-radius: 5px;
  }
  </style>
  <body>
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container">
    <a class="navbar-brand" href="/">Coding Skill</a>
		<form class="form-inline my-2 my-lg-0">			
			<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule a Free Consultation</a>
		    </form>
  </div>	
</nav>


<main role="main" class="container mt-3 offer shadow-lg p-3 mb-5 bg-white rounded">
	  <div class="row">
	    <div class="col">
				
				<h4 class='text-center mt-3 mb-4 challenge'>Get Your Dream Job </h4>
				
				<ul class='lead' style="list-style-type:none;">
					<li> 
						<span>&#10003;</span> Drawbacks of theoretical approach. 
					</li>
					<li> 
						<span>&#10003;</span> Drawbacks of practical approach. 
					</li>
					<li>
						<span>&#10003;</span> The right approach to learning to code.
					</li>												
					<li>
						<span>&#10003;</span> Skills common to all top programmers. 
					</li>
					<li>
						<span>&#10003;</span> Mental representations used by expert programmers. 
					</li>
					<li>
						<span>&#10003;</span> Effective training techniques to gain skills 
					</li>
				</ul>
	      
	    </div>
	    <div class="col border-left border-info">
				
				<h4 class='challenge text-center mt-3'> 7 Step Framework to Coding Skills Acquisition</h4>
		
				<p class='lead mb-4 text-center'>
					Learn the Effective Approach to Learning to Code
				</p>
				
				<div class="form-group ml-5 mb-0">						
				  <form method="post" action="https://www.aweber.com/scripts/addlead.pl">
							<label for="name">First Name</label>
							<input type="text" name="name" value="" class="form-control col-10">
					
					    <label for="email">Email </label>
					    <input type="text" name="email" value="" class="form-control col-10" >
							<input type="hidden" name="listname" value="awlist5322122" />
							
					    <small id="emailHelp" class="form-text text-muted text-center">No spam ever. Unsubscribe anytime.</small>
					  </div>

						<p class='text-center'>
							<input type="submit" name="submit" value="Yes, I Want to Take the Free Course Now!" class="btn btn-primary"/> 
						</p>

				</form>
	    </div>
	  </div>
</main>

    <div class="container">
			<div class="row">
			  <div class="col-md-8">
					<h1>Big O Analysis of Algorithms</h1>

<p>You need to know how to make time space trade offs when you’re solving a coding problem. Learn about the Big O analysis of algorithms. What is O(1) time? What is O(n)? Start analyzing the basic operations on the data structure you’re learning in terms of time and space complexity.</p>

<h2 id="time-space-complexity">Time Space Complexity</h2>

<p>Big O is the worst-case usage of time or space of a problem in relation to the size of input. For instance, for a tree problem, one would usually assume that the tree is unbalanced and looks like a single branch to evaluate Big O because the single branch often leads to the worst case performance of an algorithm.</p>

<p><img src="/assets/images/tree.png" alt="Tree" /></p>

<p>In the diagram above, for a well-balanced tree (on the left), it may take log(n) time to find node 5 but in the worst-case scenario it would take n time to iterate through every single node in the tree.</p>

<p>There aren’t that many types of complexity. We can assume that n indicates the length of the input and implicitly any runtime can be assumed to be multiplied by some constant factor k. O(n) is the same as O(2<em>n), O(3</em>n), O(4<em>n), O(k</em>n) etc., Here are some common time-space complexities:</p>

<h3 id="linear-on">Linear O(n)</h3>

<p>An algorithm is said to run in linear time if the execution time of the algorithm is directly proportional to the input size.</p>

<p>Examples:</p>

<ol>
  <li>Array operations like search element, find min, find max etc.</li>
  <li>Linked list operations like traversal, find min, find max etc.</li>
</ol>

<blockquote class="note">
  <strong>TIP</strong> 
  <p>
    When we need to traverse all the nodes of a data structure for some task then complexity is no less than O(n).
  </p>
</blockquote>

<p>Most optimal algorithms run in linear time. An easy way to identify this is to determine if you’re visiting every node or item once and only once. If you are, it is linear. It doesn’t matter how many operations, whether it’s 1, 2, 3, or 4 lines of code you’re executing per node. You are still doing a constant amount of work per input.</p>

<h3 id="constant--o1">Constant  O(1)</h3>

<p>Constant time algorithms have a running time independent of the input size. Mathematical formulas have fixed running times and are considered constant time. Examples:</p>

<ol>
  <li>Accessing n<sup>th</sup> element of an array.</li>
  <li>Push and pop of a stack.</li>
  <li>Enqueue and remove of a queue.</li>
  <li>Accessing an element of Hash-Table.</li>
  <li>Bucket sort.</li>
</ol>

<h3 id="logarithmic-ologn">Logarithmic O(log(n))</h3>

<p>An algorithm is said to run in logarithmic time if the execution time of the algorithm is proportional to
the logarithm of the input size. Each step of an algorithm, a significant portion of the input is pruned
out without traversing it. For example, binary search.</p>

<p>Logarithmic algorithms are often seen in trees. It’s best to think of logarithmic as the height of the tree. So, a binary search, for instance, often includes traversing down the height of a tree and can be considered logarithmic in time. Although, it may still be more accurate to say that for an unbalanced tree, the runtime is in the worst case linear.</p>

<blockquote class="note">
  <strong>LOGARITHM</strong> 
  <p>
    Logarithm is the inverse of exponents. 2<sup>3</sup> is the equivalent of 2 * 2 * 2, which is 8. Now log<sub>2</sub>8 is the inverse of 2<sup>3</sup>. It means: "how many times do you have to multiply 2 by itself to get a result of 8?". Since you have to multiply 2 by itself 3 times to get 8, log<sub>2</sub> 8 = 3. Another way to view this is: How many times do we need to divide 8 by 2 until we end up with 1?
  </p>
</blockquote>

<h3 id="superlinear-onlogn">Superlinear O(n*log(n))</h3>

<p>An algorithm is said to run in <strong>n log n</strong> time if the execution time of an algorithm is proportional to
the product of input size and logarithm of the input size.</p>

<p>Examples:</p>

<ol>
  <li>Merge-Sort</li>
  <li>Quick-Sort (Average case)</li>
  <li>Heap-Sort</li>
</ol>

<p>Most of the sorting operate in (n log n) time. This includes popular sorting algorithms like quicksort, mergesort or heapsort. Actually, quicksort has O(n<sup>2</sup>) time in worst-case complexity and O(n log n) as the average case complexity.</p>

<h3 id="quadratic-on2">Quadratic O(n<sup>2</sup>)</h3>

<p>An algorithm is said to run in logarithmic time if the execution time of an algorithm is proportional to
the square of the input size. Examples:</p>

<ol>
  <li>Bubble-Sort</li>
  <li>Selection-Sort</li>
  <li>Insertion-Sort</li>
</ol>

<h3 id="cubic-on3">Cubic O(n<sup>3</sup>)</h3>

<p>Brute force algorithms often run in O(n<sup>2</sup>) or O(n<sup>3</sup>) time where you may be looping within a loop. It’s easy to identify if you see a for-loop inside a for-loop, where for each element i you iterate through another element j, for instance.</p>

<p>A common scenario is, given two arrays, find the common elements in each array where you would simply go through each element and check whether it exists in the other array. This would execute in O(n*m) time, where n and m are the sizes of each array. It’s still great to name these brute force algorithms if you can identify them.</p>

<h3 id="exponential-o2n">Exponential O(2<sup>n</sup>)</h3>

<p>Exponential algorithms are quite terrible in running time. A classic example is determining every permutation of a set of n bits (it would take 2n combinations). Another example is computing the fibonacci sequence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fib(n) = fib(n-1) + fib(n-2)
</code></pre></div></div>

<p>where for each item, it requires the computation of two more subproblems.</p>

<p><img src="/assets/images/complexity-functions.png" alt="Complexity Functions" /></p>

<h3 id="deriving-the-runtime-function-of-an-algorithm">Deriving the Runtime Function of an Algorithm</h3>

<h4 id="constants">Constants</h4>

<p>Each statement takes a constant time to run. Time Complexity is O(1).</p>

<h4 id="loops">Loops</h4>

<p>The running time of a loop is a product of running time of the statement inside a loop and number of iterations in the loop. Time Complexity is O(n).</p>

<h4 id="nested-loop">Nested Loop</h4>

<p>The running time of a nested loop is a product of running time of the statements inside loop multiplied by a product of the size of all the loops. Time Complexity is O(n<sup>c</sup>).</p>

<p>Where c is a number of loops. For two loops, it will be O(n<sup>2</sup>).</p>

<h4 id="consecutive-statements">Consecutive Statements</h4>

<p>Just add the running times of all the consecutive statements.</p>

<h4 id="if-else-statement">if-else Statement</h4>

<p>Consider the running time of the larger of if block or else block. Ignore the other one.</p>

<h4 id="logarithmic-statement">Logarithmic Statement</h4>

<p>If each iteration is decreasing the input size by a constant factors. Time Complexity = O(log n).</p>

<h3 id="factorial-on">Factorial O(n!)</h3>

<p>These algorithms are the slowest and don’t show up that often. You might see this in combinatorial problems or the traveling salesman problem, where given n nodes, you need to find the optimal path from start to finish.</p>

<p>In your first iteration, you have a selection of n cities to visit, then n-1 cities, then n-2 cities, n-3 cities, etc., until you reach the last city. That runtime is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n * (n - 1) * (n - 2) * (n - 3) ... 1 = O(n!)
</code></pre></div></div>

<p><img src="/assets/images/complexity-classes.png" alt="Complexity Classes" /></p>

<p><img src="/assets/images/complexity-classes.png" alt="Complexity Classes" /></p>

<h2 id="some-tips">Some Tips</h2>

<p>Do not overcomplicate this like saying “This is O(3 * k *  n<sup>2</sup>), where k is the number of comparisons.” Most people don’t care about this level of detail, and you can often get away with simply saying: “This is quadratic time because we have two for-loops, each one iterating from 1 to n.”</p>

<p>One more tip - do not say “This is O(m + v + e),” when you haven’t defined what m, v, or e are. You generally want to say “… where m is the height of the matrix, v is the number of vertices, e is the number of edges, etc.,” Once you start reciting formulas without defining the constants you’re using, your analysis will appear amateurish.</p>

<p>Most interviewers will focus on time-complexity, but it is great to also consider space-complexity too. Algorithms are commonly tradeoffs between time and space. For instance, you may be able to take a polynomial algorithm and convert it to an O(n) algorithm, but it requires the creation of a hashmap of size O(n). That’s a good trade-off to be able to talk about because additional space is needed.</p>

<blockquote class="note">
  <strong>BEST CASE AND AVERAGE CASE</strong> 
  <p>
    You usually don't need to know omega and theta, though they're not that difficult. It's just the best case and average case.
  </p>
</blockquote>

<p>When assessing time vs space complexity, it would be generally better to focus on reducing time complexity at the expense of space complexity. The tradeoffs for the example of the polynomial algorithm in reducing the time complexity to O(n) at the expense of a hashmap of size O(n). Space complexity would impact mostly usage of resources (memory) but as long as it doesn’t blow up, optimizing the time efficiency comes first.</p>

<p>You generally want to optimize for time. Do not assume that time efficiency is the optimal solution without explaining the trade-offs in space. A good candidate will have mastery of time-space analysis and always be talking that through.</p>

<p>Big O is by definition for worst-case. The exception is for trees. It may help to assume that the trees are balanced though (usually giving O(logn) complexity) or for hashmaps to assume no collisions.</p>

<p>However, you can make a few assumptions usually like hashmaps will have no collisions, that trees are properly balanced, or that numbers are properly random. It’s good to give a complete analysis and say something like “on average you’ll get O(log n) though in the worst case this could be as bad as O(n) if the tree is not balanced.”</p>

<h2 id="basic-data-structures">Basic Data Structures</h2>

<p>The basic data structures to learn how to perform Big-O analysis:</p>

<p><strong>Array, Matrix, Linked List (double, single, circular)</strong></p>

<ul>
  <li>Representation</li>
  <li>Traversal</li>
  <li>Insert</li>
  <li>Find</li>
  <li>Delete</li>
  <li>Update</li>
  <li>Detect loop, find linked list circle start point</li>
</ul>

<p><strong>Stack</strong></p>

<ul>
  <li>Representation</li>
  <li>push</li>
  <li>pop</li>
  <li>peek</li>
  <li>full? / empty?</li>
</ul>

<p><strong>Queue</strong></p>

<ul>
  <li>Representation</li>
  <li>enqueue</li>
  <li>dequeue</li>
  <li>peek</li>
  <li>full? / empty?</li>
</ul>

<p><strong>Tree (Binary Tree and Binary Search Tree)</strong></p>

<ul>
  <li>search</li>
  <li>insert</li>
  <li>post-order, in-order, pre-order traversal</li>
</ul>

<p><strong>Graph</strong></p>

<ul>
  <li>Representation</li>
  <li>Implementation</li>
  <li>DFS/BFS</li>
  <li>Dijkstra’s Algorithm</li>
</ul>

<p>Feel free to add advanced data structures to this list for your level.</p>

<h2 id="pros-and-cons">Pros and Cons</h2>

<p>Create a table for each data structure to compare them. What are the time-space complexities? It’s very important to build a solid understanding of data structures and algorithms before tackling real coding interview questions.</p>


<hr/>
<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule Your Free Consultation Now</a>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

			  </div>	
			</div>
    </div>
    
    <br/>    <br/>
    <script src="/assets/js/bootstrap.min.js"></script>
    
          <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-358645-13"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-358645-13');
</script>

    
    
  </body>
</html>



