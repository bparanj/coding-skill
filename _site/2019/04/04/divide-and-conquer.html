<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Divide and Conquer Strategy - Coding Skill</title>

  <link rel="stylesheet" href="/assets/css/styles.css">
	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Divide and Conquer Strategy | Coding Skill</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Divide and Conquer Strategy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Given a function to compute on n inputs, the divide and conquer strategy splits the input into k distinct subsets, yielding k subproblems. These subproblems must be solved and then a method must be found to combine subsolutions into a solution of the whole." />
<meta property="og:description" content="Given a function to compute on n inputs, the divide and conquer strategy splits the input into k distinct subsets, yielding k subproblems. These subproblems must be solved and then a method must be found to combine subsolutions into a solution of the whole." />
<meta property="og:site_name" content="Coding Skill" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-04T00:00:00-04:00" />
<script type="application/ld+json">
{"url":"/2019/04/04/divide-and-conquer.html","headline":"Divide and Conquer Strategy","dateModified":"2019-04-04T00:00:00-04:00","datePublished":"2019-04-04T00:00:00-04:00","description":"Given a function to compute on n inputs, the divide and conquer strategy splits the input into k distinct subsets, yielding k subproblems. These subproblems must be solved and then a method must be found to combine subsolutions into a solution of the whole.","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/04/04/divide-and-conquer.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  
  <style>
  .note {
      background-color: #f7f7f7;
      line-height: 26px;
      margin: 30px 0;
      padding: 26px 30px 12px 30px;
      border-left-style: solid;
      border-left-width: 4px;
      border-color: #008000;
  	  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  		border-radius: 5px;
  }
  </style>
  <body>
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container">
    <a class="navbar-brand" href="/">Coding Skill</a>
		<form class="form-inline my-2 my-lg-0">			
			<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule a Free Consultation</a>
		    </form>
  </div>	
</nav>

    <div class="container">
			<div class="row">
			  <div class="col-md-8">
					<h1>Divide and Conquer Strategy</h1>

<p>Given a function to compute on n inputs, the divide and conquer strategy splits the input into k distinct subsets, yielding k subproblems. These subproblems must be solved and then a method must be found to combine subsolutions into a solution of the whole.</p>

<p>If the subproblems are large, then the divide and conquer strategy may possibly be reapplied. Often the subproblems resulting from a divide and conquer design are of the same type as the original problem. For those cases, the reapplication of the divide and conquer principle is naturally expressed by a recursive procedure.</p>

<p>Now smaller and smaller subproblems of the same kind as the original problem are generated, eventually producing subproblems that are small enough to be solved without splitting.</p>

<p>We can write a program template which mirrors the way an actual program based upon divide-and-conquer will look. By a program template we mean a procedure whose flow of control is clear, but whose primary operations are specified by other procedures whose precise meaning is left undefined.</p>

<h3 id="recursive-program-template">Recursive Program Template</h3>

<p>Let the n inputs be stored by the array called input. Here is the program template for divide and conquer:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
   <span class="n">input</span> 
  <span class="sr">/* 1 &lt;= p &lt;= q &lt;= n */</span>
  <span class="k">if</span> <span class="n">small</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compute</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
	<span class="sr">/* p &lt;= m &lt; q */</span>
	<span class="n">solution</span> <span class="o">=</span> <span class="n">combine</span><span class="p">(</span><span class="n">procedure</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">procedure</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>small(p, q) returns true if the input size q - p + 1 is small enough so that the answer can be computed without splitting. If so, the function compute() is invoked. Otherwise the function divide (p, q) is called. This function returns an integer which specifies where the input is to be split.</p>

<p>Let m = divide(p, q). The input is split so that input(p, m) and input(m+1, q) define instances of two subproblems. The subsolutions x and y respectively of these two subproblems are obtained by recursive application of solve(). The combine(x, y) is a function which determines the solution to input[p, q] using the solutions x and y to the subproblems input[p, m] and input[m+1, q]. If the sizes of the two subproblems are approximately equal then the computing time of solve() is naturally described by the recurrence relation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T(n) = compute(n), n small
       2T(n/2) + f(n), otherwise
</code></pre></div></div>

<p>T(n) - Time for solve() on n inputs.
compute(n) - Time to compute the answer directly for small inputs
f(n) - Time for divide and combine</p>

<p>Recurrence relations will often arise for divide and conquer based algorithms.</p>

<p>For divide and conquer based algorithms which produce subproblems of the same type as the original problem it is natural to first describe such an algorithm using recursion. But to gain efficiency it may be desirable to translate the resulting program into iterative form.</p>

<h3 id="iterative-program-template">Iterative Program Template</h3>

<p>The iterative form of divide and conquer program template:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="sr">/* declare a stack of appropriate size */</span>
  <span class="sr">/* set the stack to empty */</span>
  <span class="n">top</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
  
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">small</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">while</span> <span class="n">top</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="sr">/* decrement top  */</span>
    <span class="sr">/* process the second recursive call */</span>
    <span class="sr">/* combine two solutions into one */</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>


<hr/>
<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule Your Free Consultation Now</a>

			  </div>
	
			  <div class="col-md-4">
			    <h3 class="my-3">Coding Interview Secrets</h3>
			    <p>
						If you are feeling frustrated and overwhelmed with coding interview preparation, sign up for FREE <a href='https://codinginterview.coach/'> coaching session </a> and we will figure it all out. Why is this free? Because I believe in Zig Ziglar's quote: You can get everything in life you want if you will just help enough other people get what they want.
			    </p>
			  </div>
			</div>
    </div>
    
    <br/>    <br/>
    <script src="/assets/js/bootstrap.min.js"></script>
    
          <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-358645-13"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-358645-13');
</script>

    
    
  </body>
</html>



