<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Recursion Basics - Coding Skill</title>

  <link rel="stylesheet" href="/assets/css/styles.css">
	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Recursion Basics | Coding Skill</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Recursion Basics" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this article, we will cover the basics of recursion with a few examples. We will see how to translate recursion into an iterative equivalent." />
<meta property="og:description" content="In this article, we will cover the basics of recursion with a few examples. We will see how to translate recursion into an iterative equivalent." />
<meta property="og:site_name" content="Coding Skill" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-28T00:00:00-04:00" />
<script type="application/ld+json">
{"url":"/2019/03/28/recursion-basics.html","headline":"Recursion Basics","dateModified":"2019-03-28T00:00:00-04:00","datePublished":"2019-03-28T00:00:00-04:00","description":"In this article, we will cover the basics of recursion with a few examples. We will see how to translate recursion into an iterative equivalent.","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/03/28/recursion-basics.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  
  <style>
  .note {
      background-color: #f7f7f7;
      line-height: 26px;
      margin: 30px 0;
      padding: 26px 30px 12px 30px;
      border-left-style: solid;
      border-left-width: 4px;
      border-color: #008000;
  	  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  		border-radius: 5px;
  }
  </style>
  <body>
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container">
    <a class="navbar-brand" href="/">Coding Skill</a>
		<form class="form-inline my-2 my-lg-0">			
			<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule a Free Consultation</a>
		    </form>
  </div>	
</nav>

    <div class="container">
			<div class="row">
			  <div class="col-md-8">
					<h1>Recursion Basics</h1>

<p>In this article, we will cover the basics of recursion with a few examples. We will see how to translate recursion into an iterative equivalent.</p>

<h3 id="recursion">Recursion</h3>

<p>Recursion is a powerful programming technique. We discussed reduction in the article <a href="/2020/01/23/problem-solving-techniques-for-coding-interview.html">Problem Solving Techniques for Coding Interview</a></p>

<h4 id="simplify-and-delegate">Simplify and Delegate</h4>

<p>Recursion is a powerful kind of reduction, which can be described as follows:</p>

<ul>
  <li>If the given instance of the problem can be solved directly, solve it directly.</li>
  <li>Otherwise, reduce it to one or more simpler instances of the same problem</li>
</ul>

<p>Your only task is to simplify the original problem or to solve it directly when simplification is either unnecessary or impossible.</p>

<p>Eventually, the recursive reductions must lead to an elementary base case that can be solved by some other method.</p>

<p>Otherwise, the recursive algorithm will loop forever. The most common way to satisfy this condition is to reduce to one or more smaller instances of the same problem. So the sequence of smaller problems must eventually converge on the base case.</p>

<h3 id="why-recursion">Why Recursion?</h3>

<p>Recursive code is generally concise and easy to write than iterative equivalent. Recursion is most useful for tasks than can be defined in terms of similar subtasks. For example, sort, search and traversal problems often have simple recursive solutions.</p>

<h3 id="recursion-and-memory">Recursion and Memory</h3>

<p>Each recursive call makes a new copy of that method in memory. Once a method ends and returns some data, the copy of that returning method is removed from memory.</p>

<h3 id="fibonacci-sequence">Fibonacci Sequence</h3>

<p>Now, let’s take look at a few examples. The Fibonacci sequence 1,1,2,3,5,8,13,21,34 is defined as:</p>

<p><img src="/assets/images/fibonacci.png" alt="Fibonacci Sequence" /></p>

<p>This mathematical definition naturally leads to the recursive procedure:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The virtue of this program is that it is almost syntactically identical to the mathematical definition. However it is inefficient from the standpoint of computing time.</p>

<p>The major source of the inefficiency is not because of recursion. The reason is that many values are recomputed many times. For example, f(n-2) is computed twice, f(n-3) is computed three times and f(n-4) is computed five times.</p>

<blockquote class="note">
  <strong>DYNAMIC PROGRAMMING</strong> 
  <p>
    If a calculation such as the Fibonacci numbers must recalculate the same values many times, you can save time by storing values in a lookup table so that you need to calculate them only once.
  </p>
</blockquote>

<h4 id="greatest-common-divisor">Greatest Common Divisor</h4>

<p>The greatest common divisor (GCD) of two integers is the largest integer that evenly divides both of the numbers. For example, GCD(60, 24) is 12 because 12 is the largest integer that evenly divides both 60 and 24.</p>

<p>Compute the GCD of two nonnegative integers. Given 22 and 8, we compute gcd as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcd(22,8) = gcd(8,6) = gcd(6,2) = gcd(2,0) = 2
</code></pre></div></div>

<p>The GCD of 21 and 13 is computed as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcd(21, 13) = gcd(13,8) = gcd(8,5) = gcd(5,3) = gcd(3,2) = gcd(2,1) = gcd(1,0) = 1
</code></pre></div></div>

<blockquote class="note">
  <strong>MODULUS OPERATOR</strong> 
  <p>
    The modulus operator, which is written as % (percent symbol) in Ruby, means the remainder after division. For example, 13 % 4 is 1 because 13 divided by 4 is 3 with a remainder of 1.
  </p>
</blockquote>

<p>We begin by computing 21 mod 13. This gives us 8 as the result. You can observe that b becomes a and we again compute 13 mod 8 and so on.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; 21 % 13
 =&gt; 8
 &gt; 13 % 8
 =&gt; 5
 &gt; 8 % 5
 =&gt; 3
 &gt; 5 % 3
 =&gt; 2
 &gt; 3 % 2
 =&gt; 1
 &gt; 2 % 1
 =&gt; 0 
</code></pre></div></div>

<p>Expressing this process as a recursive procedure one gets:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span>

  <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Recursion can be used for problems that are not mathematical functions. For instance, we can search for a given number in an array by using recursion. By using recursion the need for a looping statement is removed.</p>

<h3 id="recursion-vs-iteration">Recursion vs Iteration</h3>

<p>A recursive approach mirrors the problem that we are solving. A recursive approach makes it simpler to solve a problem that may not be obvious to solve. But recursion incurs overhead for each recursive call. Because it needs space on the stack frame.</p>

<p>If we get infinite recursion, the program will run out of memory and result in stack overflow error. Any problem that can be solved recursively can also be solved iteratively.</p>

<p>A recursive algorithm can be translated to its iterative equivalent using a stack, but it’s usually more trouble than its worth.</p>

<h3 id="removing-recursion">Removing Recursion</h3>

<p>Some design techniques are inherently recursive and so recursion is a natural way to describe algorithms obtained from these techniques.</p>

<p>Recursion incurs overhead of repeated procedure calls. In the early stages of algorithm design we can use recursion. Once we are satisfied that we have a good algorithm, the recursion can be removed by translating the algorithm into an equivalent one that uses iteration.</p>

<p>Translating a recursive procedure into an equivalent procedure which uses iteration involves replacing all recursive procedure calls and return statements by equivalent non-recursive code.</p>

<blockquote class="note">
  <strong>GENERAL RECURSION REMOVAL</strong> 
  <p>
    You can remove recursion more generally by mimicking how a program calls a method recursively. Push variables onto stacks before recursion, and pop them off afterward.
  </p>
</blockquote>

<p>At the beginning of the procedure, code is inserted which declares a stack and initializes it to be empty. In the most general case, the stack will be used to hold the values of parameters, local variables, function value and return address for each recursive call.</p>

<p>The rules are for the general case. Often there are occasions when simpler rules apply. For example if the last statement of a procedure is a recursive call, then remove it by simply evaluating the new values of the parameters and branching to the beginning. A stack is not needed.</p>

<p>The gcd procedure is an example. Removing its recursion yields the following program:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">while</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">t</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">a</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The objective of removing recursion is to produce a more efficient but computationally equivalent iterative program. In some languages the compiler translates recursive procedures into efficient code.</p>

<p>Sometimes, you can remove recursion by starting with the smallest pieces of data and using them to build larger ones rather than starting at the largest scale and recursively dividing the data. This is called Bottom-up programming.</p>

<blockquote class="note">
  <strong>WHEN TO USE RECURSION</strong> 
  <p>
    The class of backtracking algorithms emerges as an ideal application of recursion, but the most obvious candidates for the use of recursion are algorithms operating on data whose structure is defined recursively.
  </p>
</blockquote>


<hr/>
<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule Your Free Consultation Now</a>

			  </div>
	
			  <div class="col-md-4">
			    <h3 class="my-3">Coding Interview Secrets</h3>
			    <p>
						If you are feeling frustrated and overwhelmed with coding interview preparation, sign up for FREE <a href='https://codinginterview.coach/'> coaching session </a> and we will figure it all out. Why is this free? Because I believe in Zig Ziglar's quote: You can get everything in life you want if you will just help enough other people get what they want.
			    </p>
			  </div>
			</div>
    </div>
    
    <br/>    <br/>
    <script src="/assets/js/bootstrap.min.js"></script>
    
          <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-358645-13"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-358645-13');
</script>

    
    
  </body>
</html>



