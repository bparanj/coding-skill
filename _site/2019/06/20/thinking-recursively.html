<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>How to Think Recursively - Coding Skill</title>

  <link rel="stylesheet" href="/assets/css/styles.css">
	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>How to Think Recursively | Coding Skill</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="How to Think Recursively" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this article, we will look at some example problems and solve it recursively and iteratively. Sometimes it is possible to define an algorithm in terms of itself. This process is called recursion. It is similar to mathematical induction." />
<meta property="og:description" content="In this article, we will look at some example problems and solve it recursively and iteratively. Sometimes it is possible to define an algorithm in terms of itself. This process is called recursion. It is similar to mathematical induction." />
<meta property="og:site_name" content="Coding Skill" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-20T00:00:00-05:00" />
<script type="application/ld+json">
{"headline":"How to Think Recursively","dateModified":"2019-06-20T00:00:00-05:00","datePublished":"2019-06-20T00:00:00-05:00","description":"In this article, we will look at some example problems and solve it recursively and iteratively. Sometimes it is possible to define an algorithm in terms of itself. This process is called recursion. It is similar to mathematical induction.","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/06/20/thinking-recursively.html"},"@type":"BlogPosting","url":"/2019/06/20/thinking-recursively.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  
  <style>
  .note {
      background-color: #f7f7f7;
      line-height: 26px;
      margin: 30px 0;
      padding: 26px 30px 12px 30px;
      border-left-style: solid;
      border-left-width: 4px;
      border-color: #008000;
  	  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  		border-radius: 5px;
  }
  </style>
  <body>
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container">
    <a class="navbar-brand" href="/">Coding Skill</a>
		<form class="form-inline my-2 my-lg-0">			
			<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule a Free Consultation</a>
		    </form>
  </div>	
</nav>


<main role="main" class="container mt-3 offer shadow-lg p-3 mb-5 bg-white rounded">
	  <div class="row">
	    <div class="col">
				
				<h4 class='text-center mt-3 mb-4 challenge'>Get Your Dream Job </h4>
				
				<ul class='lead' style="list-style-type:none;">
					<li> 
						<span>&#10003;</span> Drawbacks of theoretical approach. 
					</li>
					<li> 
						<span>&#10003;</span> Drawbacks of practical approach. 
					</li>
					<li>
						<span>&#10003;</span> The right approach to learning to code.
					</li>												
					<li>
						<span>&#10003;</span> Skills common to all top programmers. 
					</li>
					<li>
						<span>&#10003;</span> Mental representations used by expert programmers. 
					</li>
					<li>
						<span>&#10003;</span> Effective training techniques to gain skills 
					</li>
				</ul>
	      
	    </div>
	    <div class="col border-left border-info">
				
				<h4 class='challenge text-center mt-3'> 7 Step Framework to Coding Skills Acquisition</h4>
		
				<p class='lead mb-4 text-center'>
					Learn the Effective Approach to Learning to Code
				</p>
				
				<div class="form-group ml-5 mb-0">						
				  <form method="post" action="https://www.aweber.com/scripts/addlead.pl">
							<label for="name">First Name</label>
							<input type="text" name="name" value="" class="form-control col-10">
					
					    <label for="email">Email </label>
					    <input type="text" name="email" value="" class="form-control col-10" >
							<input type="hidden" name="listname" value="awlist5322122" />
							
					    <small id="emailHelp" class="form-text text-muted text-center">No spam ever. Unsubscribe anytime.</small>
					  </div>

						<p class='text-center'>
							<input type="submit" name="submit" value="Yes, I Want to Take the Free Course Now!" class="btn btn-primary"/> 
						</p>

				</form>
	    </div>
	  </div>
</main>

    <div class="container">
			<div class="row">
			  <div class="col-md-8">
					<h1>How to Think Recursively</h1>

<p>In this article, we will look at some example problems and solve it recursively and iteratively. Sometimes it is possible to define an algorithm in terms of itself. This process is called recursion. It is similar to mathematical induction.</p>

<blockquote class="note">
  <strong>MATHEMATICAL INDUCTION</strong> 
  <p>
    Mathematical induction is an important proof technique used in mathematics. Mathematical induction proof consists of two steps and these are the base step and the inductive step.
  </p>
</blockquote>

<p>The article <a href="/2020/02/13/recursion-and-mathematical-induction.html">Recursion and Mathematical Induction</a> explains how they are related to each other in more detail.</p>

<h2 id="algorithmically">Algorithmically</h2>

<p>Recursion is a way to design solutions to problems by <a href="/2019/04/04/divide-and-conquer.html">Divide and Conquer</a> or decrease-and-conquer. Reduce a problem to simpler versions of the same problem.</p>

<h2 id="semantically">Semantically</h2>

<p>Recursion is a programming technique where a function calls itself. The solutions has one or more base cases that are easy to solve. Must solve the same problem on some other input with the goal of simplifying the larger problem input.</p>

<p>Recursion can also be single, when the method calls itself once or multiple, when the method calls itself multiple times.</p>

<p>Notice that the method does not return a value in the inductive step, it returns a function instead. Each time a procedure is activated recursively, a new set of local, bound variables is created. Although they have the same names as their corresponding elements in the set local to the previous instance of the procedure, their values are distinct.</p>

<h2 id="stack-depth">Stack Depth</h2>

<p>Normally, a computer allocates two areas of memory for a program: the stack and the heap.</p>

<p>The stack is used to store information about method calls. When a piece of code calls a method, information about the call is placed on the stack. When the method returns, that information is popped off the stack, so the program can resume execution just after the point where it called the method.</p>

<p>The list of methods that were called to get to a particular point of execution is called the call stack.</p>

<p>The heap is another piece of memory that the program can use to create variables and perform calculations.</p>

<p>Typically, the stack is much smaller than the heap. The stack usually is large enough for normal programs because your code typically doesn’t include methods calling other methods to a very great depth. However, recursive algorithms can sometimes create extremely deep call stacks and exhaust the stack space, causing the program to crash.</p>

<p>The article <a href="/2019/03/28/recursion-basics.html">Recursion Basics</a> has a section on <em>Removing Recursion</em> that explains how you can prevent this kind of deep recursion from exhausting the stack space and crashing the program.</p>

<p>For this reason, it’s important to evaluate the maximum depth of recursion that a recursive algorithm requires in addition to studying its run time and memory requirements.</p>

<h2 id="summation">Summation</h2>

<p>A recursive function is a function that is defined by itself or that calls itself. The sum function is given as an example, which is defined as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(n) = 1 + 2 + ... + n
</code></pre></div></div>

<p>That means, the first n natural numbers are added. So, for n = 4 we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(4) = 1 + 2 + 3 + 4 = 10
</code></pre></div></div>

<p>If we want to calculate the result of the sum function for a certain n and we already know the result for n - 1, n just has to be added to this result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(n) = sum(n-1) + n
</code></pre></div></div>

<p>Such a definition is called a recursive step. In order to calculate the sum function for some n in this way, we still need the base case for the smallest n:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(1) = 1
</code></pre></div></div>

<p>Using these definitions, we are now able to calculate the sum function for some n:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(4) = sum(3) + 4
       = (sum(2) + 3) + 4
	   = ((sum(1) + 2) + 3) + 4
	   = ((1 + 2) + 3) + 4
	   = 10
</code></pre></div></div>

<p>We can implement this in code. Here is the C language function to compute sum of first n positive numbers:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see the last line that makes the recursive call is using the same form we saw earlier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(n) = sum(n-1) + n
</code></pre></div></div>

<blockquote class="note">
  <strong>STACK OVERFLOW</strong> 
  <p>
    If you miss the base case, the function will get into an infinite recursion causing the stack overflow error.
  </p>
</blockquote>

<h2 id="multiplication">Multiplication</h2>
<h3 id="recursive-solution">Recursive Solution</h3>

<p>Multiply two numbers using multiplication operator. For instance:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 * 3 = 5 + 5 + 5
</code></pre></div></div>
<p>We add 5, 3 times. This is the same as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 * 3 = 5 + 5 * (3 - 1)
</code></pre></div></div>

<p>We keep going until we multipy by 1. This is the base case.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 * 3 = 5 + 5 + 5 * (2 - 1)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 * 3 = 5 + 5 + 5 * 1
</code></pre></div></div>

<p>We can generalize this as below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a * b = (a + a + a + a + a + a)
</code></pre></div></div>

<p>Add a to itself b times.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a * b = (a + a + a + a + a + a) 
		b times
	= a + (a + a + a + a + a)
		b - 1 times
  = a + a * (b-1)
</code></pre></div></div>

<p>The last line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a + a * (b-1)
</code></pre></div></div>

<p>is called the Recursive Reduction. Notice that the original problem is reduced to a smaller problem that is similar to the original problem.</p>

<h2 id="multiplication-1">Multiplication</h2>

<h3 id="iterative-solution">Iterative Solution</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">a</span>
    <span class="n">b</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<blockquote class="note">
  <strong>RECURSIVE THINKING</strong> 
  <p>
    It is not natural for human mind to think recursively. Recursion and mathematical induction are based on the same idea. Think of recursion as an executable version of induction. When programming recursively, think inductively.
  </p>
</blockquote>

<h2 id="exponent">Exponent</h2>

<h3 id="problem-statement">Problem Statement</h3>

<p>Compute the n<sup>th</sup> power of a number X<sup>n</sup>.</p>

<h3 id="mathematical-definition">Mathematical Definition</h3>

<p>The mathematical function is defined as follows:</p>

<p>For n = 0, X<sup>n</sup> = 1</p>

<p>Otherwise if n &gt; 0 X<sup>n</sup> = X * X<sup>n-1</sup></p>

<h3 id="program">Program</h3>

<p>The C implementation of exponentiation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">power</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote class="note">
  <strong>TIME AND MEMORY</strong> 
  <p>
    The recursive solution takes more time and more memory than the corresponding iterative solution.
  </p>
</blockquote>

<p>In situations where both iterative and recursive solutions are equally easy to code, choose iterative solution. The advantage of recursion is that sometimes a solution that is very complex to understand can be easily visualized recursively. We just need to solve the problem for the base case and leave the rest of the problem to be solved by recursion. Tower of Hanoi problem is an example.</p>

<h2 id="head-recursion-and-tail-recursion">Head Recursion and Tail Recursion</h2>

<p>If the recursive call is made before the function performs its own task, then it is called Head Recursion.</p>

<p>Tail recursion occurs when the last thing a singly recursive algorithm does before returning is call itself.</p>

<p>For example, consider the following implementation of the Factorial algorithm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Integer: Factorial(Integer: n)
      If (n == 0) Then Return 1
      Integer: result = n * Factorial(n - 1)
      Return result
  End Factorial
</code></pre></div></div>

<p>The algorithm starts by checking to see whether it needs to call itself recur- sively or whether it can simply return the value 1. If the algorithm must call itself, it does so, multiplies the returned result by n, and returns the result.</p>

<p>You can convert this recursive version of the algorithm into a nonrecursive version by using a loop. Within the loop, the algorithm performs whatever tasks the original algorithm did.</p>

<p>Before the end of the loop, the algorithm should set its parameters to the values they had during the recursive call. If the algorithm returns a value, as the Factorial algorithm does, you need to create a variable to keep track of the return value.</p>

<p>When the loop repeats, the parameters are set for the recursive call, so the algorithm does whatever the recursive call did.</p>

<p>The loop should end when the condition occurs that originally ended the recursion.</p>

<p>For the Factorial algorithm, the stopping condition is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n == 0
</code></pre></div></div>

<p>so that condition controls the loop. When the algorithm calls itself recursively, it decreases its parameter n by 1, so the non-recursive version should also decrease n by 1 before the end of the loop.</p>

<p>The following pseudocode shows the new nonrecursive version of the Factorial algorithm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Integer: Factorial(Integer: n)
      // Make a variable to keep track of the returned value.
      // Initialize it to 1 so we can multiply it by returned results.
      // (The result is 1 if we do not enter the loop at all.)
      Integer: result = 1
      // Start a loop controlled by the recursion stopping condition.
      While (n != 0)
          // Save the result from this "recursive" call.
          result = result * n
          // Prepare for "recursion."
n=n- 1 Loop
      // Return the accumulated result.
      Return result
  End Factorial
</code></pre></div></div>

<p>This algorithm looks a lot longer than it really is because of all the comments.</p>

<p>Removing tail recursion is straightforward enough that some compilers can do it automatically to reduce stack space requirements.</p>

<p>Of course, the problem with the Factorial algorithm isn’t the depth of recursion, it’s the fact that the results become too big to store in data types of fixed size.</p>

<blockquote class="note">
  <strong>TAIL RECURSION REMOVAL</strong> 
  <p>
    A tail recursion is very easy to re-write in the form of a loop. You can replace tail recursion with a loop that resets parameters before the end of the loop.
  </p>
</blockquote>

<p>Tail-recursive functions can always be translated directly into iterative functions. The reason is that when we do the tail call, we are effectively replacing the current copy of the function with a new copy with new arguments. We can reuse the parent copy by assigning new values to its arguments and jumping back to the top of the function.</p>

<h2 id="when-not-to-use-recursion">When Not to Use Recursion</h2>

<p>Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms. This does not mean that such recursive definitions guarantee that a recursive algorithm is the best way to solve the problem.</p>

<blockquote class="note">
  <strong>TIP</strong> 
  <p>
    If there is only one single recursive call either at the end or the beginning, then we must avoid using recursion.
  </p>
</blockquote>

<p>Every recursive program can be transformed into an iterative one. This involves the explicit handling of a recursion stack and these operations will often obscure the essence of a program to such an extent that it becomes difficult to comprehend.</p>

<p>Algorithms which by their nature are recursive rather than iterative should be formulated as recursive procedures. A good example is QuickSort.</p>

<p>We can use recursion in cases the underlying data structures let the choice of recursive solutions appear obvious and natural.</p>

<p>For example, trees are naturally recursive because branches divide into smaller branches that divide into still smaller branches and so on. For that reason, algorithms that build, draw, and search trees are often recursive.</p>

<p>Some problems are naturally recursive. They have a structure that allows a recursive algorithm to easily keep track of its progress and find a solution.</p>

<blockquote class="note">
  <strong>TIP</strong> 
  <p>
    Recursive algorithms are appropriate when the problem to be solved, or the function to be computed, or the data structure to be processed are already defined in recursive terms.
  </p>
</blockquote>


<hr/>
<a class="btn btn-primary btn-lg" href="https://go.oncehub.com/BalaParanj" role="button">Schedule Your Free Consultation Now</a>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

			  </div>	
			</div>
    </div>
    
    <br/>    <br/>
    <script src="/assets/js/bootstrap.min.js"></script>
    
          <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-358645-13"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-358645-13');
</script>

    
    
  </body>
</html>



